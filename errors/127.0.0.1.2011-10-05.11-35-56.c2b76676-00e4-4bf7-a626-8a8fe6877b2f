(dp1
S'output'
p2
S''
sS'layer'
p3
S'/home/ian/Dropbox/Web_Pages/web2py-linux/applications/paideia/controllers/exploring.py'
p4
sS'code'
p5
S'# coding: utf8\n\nimport random,re,datetime\n\ndef set_path():\n    #set the quiz and retrieve its data\n    if not session.path_length:\n        the_path = db(db.quizzes.id == request.vars.path).select()\n        session.path_id = the_path[0].id\n        session.path_length = the_path[0].length\n        session.path_name = the_path[0].quiz\n        session.path_freq = the_path[0].frequency\n        session.path_tags = the_path[0].tags\n\ndef set_counter():\n    #include this question in the count for this quiz, send to \'end\' if quiz is finished\n    if session.q_counter:\n        if int(session.q_counter) >= int(session.path_length):\n            session.q_counter = 0\n            redirect(URL(\'index\', args=[\'end\']))\n            return dict(end="yes")\n        else:\n            session.q_counter += 1\n    else:\n        session.q_counter = 1\n\ndef get_question():\n\n    #still need to code following conditions:\n    #include only tags for this quiz\n    #include only frequency for this quiz\n\n    # (db.questions.id == db.question_records.question) joins questions to records\n    # (db.question_records.name==auth.user_id) filters based on current user\n    # (db.question_records.last_right != datetime.date.today()) removes questions gotten right today\n    q_not_today =  db((db.questions.id == db.question_records.question) & (db.question_records.name==auth.user_id) & (db.question_records.last_right != datetime.date.today())).select()\n\n    #finds questions that haven\'t yet been tried by this user (using left join)\n    q_fresh = db(db.question_records.question==None).select(db.questions.ALL, db.question_records.ALL, left=db.question_records.on(db.questions.id==db.question_records.question))\n\n    #old_list = db(db.question_records.name==auth.user_id).select()\n    #q_fresh = db(~db.questions.id.belongs(old_list)).select()\n\n    the_switch = random.randint(0,1)\n    #randomly choose between review (haven\'t answered correct today) and totally new\n    if q_not_today and the_switch == 0:\n        questions = q_not_today\n        session.quiz_type = "regular review (haven\'t gotten correct today)"\n        question_count = len(questions) - 1\n        question_index = random.randint(0,question_count)\n        question_obj = questions[question_index].questions\n    elif q_fresh:\n        questions = q_fresh\n        session.quiz_type = "fresh questions (first try)"\n        question_count = len(questions) - 1\n        question_index = random.randint(0,question_count)\n        question_obj = questions[question_index]\n    #fallback is totally random review (in case all have been tried and gotten correct today)\n    else:\n        questions = db(db.questions.id > 0).select()\n        session.quiz_type = "random"\n        question_count = len(questions) - 1\n        question_index = random.randint(0,question_count)\n        question_obj = questions[question_index]\n\n    session.qID = question_obj.id\n    session.question_text = question_obj.question\n    session.answer = question_obj.answer\n    session.answer2 = question_obj.answer2\n    session.answer3 = question_obj.answer3\n    session.readable_answer = question_obj.readable_answer\n\n@auth.requires_login()\ndef index():\n\n    #after user selects quiz (or \'next question\')\n    if request.args(0) == \'ask\':\n        if not request.vars.response:\n            set_path()\n            set_counter()\n            get_question()\n\n        form = SQLFORM.factory(\n            Field(\'response\', \'string\', requires=IS_NOT_EMPTY())\n        )\n        if form.accepts(request.vars,session):\n            session.response = request.vars.response\n            redirect(URL(\'index\', args=[\'reply\']))\n\n        return dict(question=session.question_text, form=form)\n\n    #after submitting answer\n    elif request.args(0) == \'reply\':\n        #get the question that was asked\n        q_ID = session.qID\n        the_q = db(db.question_records.question==q_ID).select()\n        #see whether answer matches any of the three answer fields\n        if re.match(session.answer, session.response, re.I):\n            session.eval = \'correct\'\n            rightCount = 1\n            wrongCount = 0\n            if the_q:\n                wrongDate = the_q[0].last_wrong\n            else:\n                wrongDate = request.now\n            rightDate = request.now\n            session.score = 1\n        elif re.match(session.answer2,session.response) and session.answer2 != \'null\':\n            session.eval = \'partial\'\n            rightCount = 0\n            wrongCount = 0\n            if the_q:\n                wrongDate = the_q[0].last_wrong\n                rightDate = the_q[0].last_right\n            else:\n                wrongDate = request.now\n                rightDate = request.now\n            session.score = 0.5\n        elif re.match(session.answer3,session.response) and session.answer3 != \'null\':\n            session.eval = \'partial\'\n            rightCount = 0\n            wrongCount = 0\n            if the_q:\n                wrongDate = the_q[0].last_wrong\n                rightDate = the_q[0].last_right\n            else:\n                wrongDate = request.now\n                rightDate = request.now\n            session.score = 0.3\n        else:\n            session.eval = "wrong"\n            wrongCount = 1\n            rightCount = 0\n            if the_q:\n                rightDate = the_q[0].last_right\n            else:\n                rightDate = request.now\n            wrongDate = request.now\n            session.score = 0\n        #If the user has already attempted this question once, update their record for this question\n        if db((db.question_records.name==auth.user_id)&(db.question_records.question==q_ID)).select():\n            timesR = the_q[0].times_right\n            timesW = the_q[0].times_wrong\n            newTimesR = int(timesR) + int(rightCount)\n            newTimesW = int(timesW) + int(wrongCount)\n            db(db.question_records.question==q_ID).update(times_right=newTimesR, times_wrong=newTimesW, last_right=rightDate, last_wrong=wrongDate)\n        #if the user hasn\'t attempted this question, create a new record for it\n        else:\n            db.question_records.insert(question=q_ID, times_right=rightCount, times_wrong=wrongCount)\n\n        #build response to user\n        if session.eval == \'correct\':\n            the_reply = "Right. \xce\x9a\xce\xac\xce\xbb\xce\xb7."\n        elif session.eval == \'partial\':\n            the_reply = "\xce\x9f\xe1\xbd\x90 \xce\xba\xce\xac\xce\xba\xce\xbf\xcf\x82. You\'re close."\n        else:\n            the_reply = "Incorrect. Try again!"\n        the_answer = session.readable_answer\n        return dict(reply=the_reply, answer=the_answer, raw_answer=session.answer, score=session.score)\n\n    #when first arrive at start page\n    else:\n        the_quizzes = db().select(db.quizzes.ALL, orderby=db.quizzes.quiz)\n        return dict(quizzes = the_quizzes)\n\nresponse._vars=response._caller(index)\n'
p6
sS'snapshot'
p7
(dp8
sS'traceback'
p9
S'Traceback (most recent call last):\n  File "/home/ian/Dropbox/Web_Pages/web2py-linux/gluon/restricted.py", line 194, in restricted\n    exec ccode in environment\n  File "/home/ian/Dropbox/Web_Pages/web2py-linux/applications/paideia/controllers/exploring.py", line 166, in <module>\n  File "/home/ian/Dropbox/Web_Pages/web2py-linux/gluon/globals.py", line 149, in <lambda>\n    self._caller = lambda f: f()\n  File "/home/ian/Dropbox/Web_Pages/web2py-linux/gluon/tools.py", line 2456, in f\n    return action(*a, **b)\n  File "/home/ian/Dropbox/Web_Pages/web2py-linux/applications/paideia/controllers/exploring.py", line 81, in index\n    get_question()\n  File "/home/ian/Dropbox/Web_Pages/web2py-linux/applications/paideia/controllers/exploring.py", line 66, in get_question\n    session.qID = question_obj.id\n  File "/home/ian/Dropbox/Web_Pages/web2py-linux/gluon/dal.py", line 3851, in __getattr__\n    return self[key]\n  File "/home/ian/Dropbox/Web_Pages/web2py-linux/gluon/dal.py", line 3842, in __getitem__\n    return dict.__getitem__(self, key)\nKeyError: \'id\'\n'
p10
s.